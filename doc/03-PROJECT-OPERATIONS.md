# 복잡한 프로젝트 운용에서의 장점, 단점, 보완점

> 작성 관점: 프로젝트 매니저
> 최종 업데이트: 2026-02-13

## 1. 장점: 왜 스킬 기반 검증인가

### 1.1 규칙의 명시적 문서화

대부분의 프로젝트에는 **암묵지(Tacit Knowledge)**가 존재합니다.

- "그 파일은 건드리면 안 돼" → `verify-*` 스킬로 명시화
- "API 응답은 항상 이 포맷이어야 해" → 워크플로우의 PASS/FAIL 기준으로 명시화
- "테스트 없이 머지하면 안 돼" → 검증 단계에 테스트 커버리지 체크 포함

**실질적 효과:** 새 팀원의 온보딩 시간 단축. 시니어 개발자의 "이건 원래 이렇게 해야 해"를 스킬로 캡처하면, 주니어도 동일한 품질을 유지할 수 있습니다.

### 1.2 검증의 일관성

사람은 피로하고, 기분에 따라 리뷰 강도가 달라집니다. 스킬은 항상 동일한 기준으로 검증합니다.

| 상황 | 사람 리뷰어 | 스킬 검증 |
|------|-----------|---------|
| 금요일 오후 5시 | 대충 LGTM | 동일 기준 적용 |
| 100번째 PR | 리뷰 피로 | 동일 기준 적용 |
| 긴급 핫픽스 | "일단 넘기자" | 동일 기준 적용 |

### 1.3 점진적 채택 가능

전체 CI/CD를 한번에 바꿀 필요가 없습니다:

```
Week 1: verify-naming-convention 하나만 추가
Week 2: 팀이 익숙해지면 verify-api-contracts 추가
Week 3: verify-test-coverage 추가
...
```

기존 린터나 테스트와 충돌하지 않고, 그 위에 **프로젝트 고유 레이어**를 쌓는 방식입니다.

### 1.4 자연어 기반 확장

ESLint 플러그인을 만들려면 AST를 이해해야 합니다. 스킬은 마크다운으로 작성합니다. 비개발자(PM, QA)도 검증 규칙을 제안하고 작성할 수 있습니다.

### 1.5 자기 문서화(Self-Documenting)

스킬 자체가 "왜 이 규칙이 존재하는지"를 설명하는 문서입니다. Purpose 섹션이 규칙의 이유를, Exceptions가 경계 조건을 설명합니다.

## 2. 단점: 솔직한 한계

### 2.1 AI 실행의 비결정성

동일한 스킬을 두 번 실행해도 결과가 미세하게 다를 수 있습니다. AI가 워크플로우를 해석하는 방식이 매번 완전히 동일하지는 않기 때문입니다.

**리스크 수준:** 중 — 명확한 grep/glob 패턴은 결정적이지만, "코드를 읽고 판단하라"는 지시는 비결정적입니다.

### 2.2 실행 속도

각 스킬 실행은 AI와의 다중 왕복(round-trip)을 필요로 합니다. 10개의 verify 스킬을 순차 실행하면 수 분이 걸릴 수 있습니다.

**비교:**
- ESLint: 수천 파일을 수 초 내 검사
- verify-implementation: 파일당 AI 호출 필요, 분 단위

### 2.3 버전 관리의 복잡성

스킬이 코드와 함께 진화해야 하므로, "어떤 버전의 코드에 어떤 버전의 스킬이 맞는지" 추적이 필요합니다. manage-skills가 이를 돕지만, 브랜치 간 스킬 충돌은 수동 해결이 필요할 수 있습니다.

### 2.4 디버깅의 어려움

스킬이 예상과 다르게 동작할 때, 원인을 파악하기 어렵습니다:
- 마크다운 지시가 모호했는가?
- AI가 문맥을 다르게 해석했는가?
- Related Files에 누락이 있었는가?

전통적 코드의 스택 트레이스 같은 디버깅 도구가 없습니다.

### 2.5 단일 에이전트 의존

현재 Claude에만 동작합니다. 에이전트 전환 시 스킬 포맷 호환성이 보장되지 않습니다.

## 3. 보완점: 실전에서의 해결 방안

### 3.1 결정성 강화 전략

```
나쁜 예: "이 파일이 올바른 패턴을 따르는지 확인하세요"

좋은 예: "src/api/*.ts 파일에서 아래 grep 패턴을 실행하세요:
         grep -n 'export.*Handler' src/api/*.ts
         각 결과에 'authMiddleware'가 같은 파일에 존재하는지 확인하세요"
```

**원칙:** 워크플로우에 **구체적인 도구 호출과 판정 기준**을 명시할수록 결정성이 높아집니다.

### 3.2 실행 속도 최적화

- **필터링 우선**: 변경된 파일만 검증 (manage-skills의 git diff 기반 접근)
- **병렬 인지**: 독립적인 검증을 묶어서 실행하도록 스킬 설계
- **캐싱 마커**: 이전 검증 통과 파일을 마킹하여 재검증 스킵

### 3.3 디버깅 지원

각 verify 스킬에 **Verbose Mode** 섹션을 추가합니다:

```markdown
## Debug Mode

When invoked with `--verbose`:
- Print each grep/glob command before execution
- Show match count per file
- Display the exact PASS/FAIL decision logic applied
```

### 3.4 팀 규모별 운영 전략

| 팀 규모 | 권장 전략 |
|---------|---------|
| 1-3명 | 핵심 규칙 3-5개만 스킬화. 나머지는 코드 리뷰로 |
| 4-10명 | 도메인별 스킬 구성. PR 전 /verify-implementation 필수화 |
| 10명+ | 스킬 전담자(Skill Champion) 지정. CI 통합 검토 |

### 3.5 스킬 리뷰 프로세스

스킬도 코드와 같은 리뷰를 받아야 합니다:

1. 새 스킬 생성 → PR에 포함
2. 팀 리뷰: "이 규칙이 정말 필요한가?"
3. 시범 운영: 1주간 경고만 (FAIL이어도 블로킹하지 않음)
4. 정식 채택: 블로킹 모드로 전환

## 4. ROI 판단 기준

스킬 시스템 도입이 가치 있는 프로젝트의 특성:

- **규칙이 많고 암묵적인 프로젝트** — 레거시 코드, 복잡한 도메인
- **팀원 이동이 잦은 프로젝트** — 온보딩 비용 절감
- **규제 준수가 필요한 프로젝트** — 감사 추적(Audit Trail) 가능
- **장기 유지보수 프로젝트** — 규칙이 축적되는 가치

스킬 시스템이 과도할 수 있는 경우:

- 1-2주 단기 프로젝트
- 혼자 개발하는 프로토타입
- 규칙이 거의 없는 자유로운 프로젝트
