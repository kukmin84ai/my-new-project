# 스킬 아키텍처 심층 해설

> 작성 관점: 시스템 설계자
> 최종 업데이트: 2026-02-13

## 1. "스킬"이란 무엇인가

Claude Code에서 스킬(Skill)은 **재사용 가능한 지시서(Instruction Set)**입니다. 코드가 아닌 마크다운으로 작성되지만, AI가 이 지시서를 읽고 도구를 호출하여 실행하므로 사실상 **선언적 프로그래밍**에 해당합니다.

### 전통적 자동화와의 차이

| 측면 | 전통적 스크립트 | Claude 스킬 |
|------|----------------|-------------|
| 실행 주체 | 인터프리터/컴파일러 | AI 에이전트 |
| 오류 대응 | 예외 처리 코드 필요 | AI가 맥락 기반 판단 |
| 확장 방식 | 새 함수/모듈 작성 | 마크다운 섹션 추가 |
| 사용자 상호작용 | CLI 프롬프트/GUI | 자연어 대화 |
| 유지보수 | 코드 수정 + 테스트 | 문서 수정 |

핵심 인사이트: 스킬은 **"AI에게 주는 SOP(Standard Operating Procedure)"**입니다.

## 2. 이 프로젝트의 두 스킬이 가진 진짜 의미

### verify-implementation: 품질 게이트

이 스킬의 본질은 **CI/CD 파이프라인의 품질 게이트**를 AI 세션 안으로 가져온 것입니다.

전통적으로 코드 품질 검증은 이렇게 이루어집니다:
- ESLint → 코드 스타일
- TypeScript Compiler → 타입 안전성
- Jest → 기능 정합성
- SonarQube → 코드 메트릭

`verify-implementation`은 이 모든 것의 **상위 레이어**입니다. 정적 분석 도구가 잡지 못하는 **프로젝트 고유 규칙**을 검증합니다.

예시:
- "모든 API 엔드포인트에는 반드시 인증 미들웨어가 있어야 한다"
- "React 컴포넌트에서 직접 fetch를 호출하면 안 된다"
- "환경변수는 반드시 config 모듈을 통해 접근해야 한다"

이런 규칙들은 ESLint 커스텀 룰로 만들 수도 있지만, 스킬 방식이 **10배 빠르게 정의 가능**합니다.

### manage-skills: 살아있는 문서

소프트웨어 개발에서 가장 빨리 부패하는 것이 문서입니다. `manage-skills`는 이 문제를 정면으로 다룹니다.

**핵심 원리: Git diff 기반 변경 감지**

```
코드 변경 발생
    ↓
git diff로 변경 파일 목록 수집
    ↓
각 파일을 기존 스킬의 커버리지와 매칭
    ↓
커버되지 않는 영역 → 새 스킬 생성 제안
커버되지만 변경된 영역 → 기존 스킬 업데이트 제안
    ↓
사용자 확인 후 자동 적용
```

이것은 사실상 **코드 커버리지(Code Coverage)**의 개념을 **규칙 커버리지(Rule Coverage)**로 확장한 것입니다.

## 3. 메타 스킬 패턴의 의미

이 프로젝트가 채택한 패턴은 **메타 스킬(Meta-Skill)** 패턴입니다.

```
메타 스킬 (verify-implementation)
    ├── 도메인 스킬 A (verify-api)
    ├── 도메인 스킬 B (verify-types)
    └── 도메인 스킬 C (verify-ui)

관리 스킬 (manage-skills)
    └── 메타 스킬과 도메인 스킬 전체를 유지보수
```

이 구조의 장점:

1. **단일 진입점(Single Entry Point)**: `/verify-implementation` 하나만 기억하면 됩니다
2. **관심사 분리**: 각 도메인 스킬은 자신의 영역만 알면 됩니다
3. **점진적 성장**: 스킬을 하나씩 추가해도 시스템이 자연스럽게 확장됩니다
4. **자기 유지**: manage-skills가 전체의 정합성을 유지합니다

## 4. SKILL.md 해부학

모든 스킬은 동일한 구조를 따릅니다:

```
┌─ Frontmatter (YAML) ──────────────┐
│  name, description,                │
│  disable-model-invocation,         │
│  argument-hint                     │
└────────────────────────────────────┘
         │
┌─ Purpose ──────────────────────────┐
│  이 스킬이 "왜" 존재하는지          │
│  2-5개의 검증 카테고리              │
└────────────────────────────────────┘
         │
┌─ When to Run ──────────────────────┐
│  "언제" 실행해야 하는지              │
│  3-5개의 트리거 조건                │
└────────────────────────────────────┘
         │
┌─ Workflow ─────────────────────────┐
│  "어떻게" 실행하는지                │
│  순서가 있는 단계별 지침             │
│  각 단계에 도구 지정                │
│  PASS/FAIL 기준 명시                │
└────────────────────────────────────┘
         │
┌─ Exceptions ───────────────────────┐
│  "무엇이 아닌지" (거짓양성 방지)    │
│  2-3개의 예외 케이스                │
└────────────────────────────────────┘
         │
┌─ Related Files ────────────────────┐
│  이 스킬이 참조하는 실제 파일들      │
│  파일 경로 + 역할 테이블            │
└────────────────────────────────────┘
```

**설계 철학:** 각 섹션은 AI가 실행 결정을 내리는 데 필요한 정보를 정확히 제공합니다. Workflow는 "할 일"을, Exceptions는 "하지 말 일"을, Related Files는 "어디서"를 담당합니다.

## 5. 스킬 간 통신 메커니즘

현재 스킬들은 직접 통신하지 않습니다. 대신 **파일 시스템을 공유 상태(Shared State)**로 사용합니다:

```
manage-skills가 새 스킬 생성
    ↓
verify-implementation/SKILL.md의 Target Skills 테이블에 등록
    ↓
다음 /verify-implementation 실행 시 자동으로 새 스킬 포함
```

이것은 의도적인 설계입니다. 스킬 간 직접 의존성을 만들면 복잡도가 기하급수적으로 증가하므로, **파일 기반 느슨한 결합(Loose Coupling)**을 채택한 것입니다.

## 6. `disable-model-invocation: true`의 의미

두 스킬 모두 이 옵션이 켜져 있습니다. 이는 AI가 스스로 이 스킬을 호출하지 않고, **반드시 사용자가 명시적으로 실행**해야 한다는 뜻입니다.

이것이 중요한 이유: 검증과 스킬 관리는 사이드 이펙트가 있는 작업입니다. 파일을 수정하고, 리포트를 생성하므로, 사용자의 의도 없이 실행되면 안 됩니다.
